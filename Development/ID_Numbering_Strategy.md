# ID 채번 전략

ID 채번(Numbering)이란, 데이터베이스나 애플리케이션에서 각 레코드에 고유 식별자(ID)를 자동으로 할당하는 과정을 말한다. ID 채번을 하는 목적은, 레코드를 고유하게 구분하여 조회/수정/삭제 작업 시 충돌을 방지하기 위함이다. 우리는 자주 DB가 자동으로 ID를 생성해주는 `AUTO-INCREMENT` 방식을 사용하지만, 몇몇 상황에서는 이 방식이 문제가 발생할 수 있다.

## AUTO-INCREMENT 무엇이 문제인가?

우선 MySQL의 `AUTO-INCREMENT` 방식은 테이블에 숫자형 PK 컬럼을 만들고, 매 INSERT 시 자동으로 1씩 증가시켜 새로운 ID를 부여하는 DB 중심의 ID 채번 전략이다. (`AUTO-INCREMENT` 방식이란, MySQL의 ID 채번 전략 중 하나이며, PostgreSQL의 SERIAL와 유사하다. 여기서는 DB 중심의 ID를 순차적으로 증가시켜나가는 방식을 통틀어서 AUTO-INCREMENT라고 말하겠다.) AUTO-INCREMENT는 단일 DB에 의존하고, 동시성 병목, 복제/샤딩의 한계가 있기 때문에 대용량 트래픽 및 분산 환경에서 다음과 같은 문제가 발생할 수 있다.

### AUTO-INCREMENT의 문제점 및 발생 상황

- **쓰기 병목(Write Bottleneck)**
  - 모든 클라이언트가 단일 시퀀스 생성 지점(마스터 DB)에 요청 → 동시 INSERT 시 **락 대기** 발생
    - 대규모 트래픽 환경에서 처리량(throughput)이 급격히 떨어짐 [pythian.com](https://www.pythian.com/blog/business-insights/case-auto-increment-mysql?utm_source=chatgpt.com)
- **마스터 장애 시 단일 장애점(SPOF)**
  - 마스터 DB가 다운되면 시퀀스 발급 자체가 중단 → 서비스 전체 정지
  - HA(High Availability) 구성 시에도 **비동기 복제(async replication)** 특성상 중복(ID 충돌) 또는 누락(간극) 위험 [pythian.com](https://www.pythian.com/blog/business-insights/case-auto-increment-mysql?utm_source=chatgpt.com)
- **다중 DB·샤딩 환경 한계**
  - 샤드별 AUTO_INCREMENT를 설정해도, **ID 충돌 방지**를 위해 서로 다른 시작값(offset)·증가폭(step)을 관리해야 함
  - 서버 추가·제거 때마다 설정 변경 필요 → 운영 복잡도 폭증 [linkedin.com](https://www.linkedin.com/pulse/high-volume-databases-id-strategies-discovering-uuid-bhimavarapu-curuc?utm_source=chatgpt.com)
- **롤백·트랜잭션 실패 시 공백(ID Gap)**
  - 트랜잭션이 취소돼도 시퀀스는 이미 증가 → 번호 건너뛰기 발생 (Gap)
  - 일부 시스템에서 연속성 요구 시 문제

그렇다면, AUTO-INCREMENT 이외에는 어떤 채번 전략들이 있고, 분산 환경에서도 안전하게 사용 가능한 채번 전략은 무엇일까?

## 다양한 ID 채번 전략

### 1. DB 중심 생성 전략

#### 1.1. AUTO-INCREMENT / SERIAL

- **장점**
  - 구현이 가장 간단
  - DB가 보장하는 안정적인 일관성(atomicity)
- **단점**
  - 모든 INSERT가 DB에 의존 → 쓰기 병목 발생
  - 여러 인스턴스가 동시에 INSERT 시 순서 대기 현상

#### 1.2. SEQUENCE + Hi/Lo

- **작동 원리**
    1. SEQUENCE에서 큰 덩어리(예: 1000개)만큼 값 획득
    2. 애플리케이션 캐시한 범위 내에서 Hi/Lo로 세부 채번
- **장점**
  - DB round-trip 횟수 획기적 절감 → 처리량 증가
  - 순차 증가 보장(인덱스 단편화 최소화)
- **단점**
  - 애플리케이션 재시작 시 미소진 블록 손실(공백 ID 발생)
  - 캐시 크기 조정 필요(메모리·동시성 고려)

### 2. 애플리케이션(분산) 생성 전략

#### 2.1. UUID (v4)

- **장점**
  - 완전 분산, 충돌 가능성 거의 없음
  - DB 의존 완전 제거
- **단점**
  - 128비트 랜덤 값 → 인덱스 단편화 심화, 성능 저하
  - 읽기 쉬운 순서성을 보장하지 않음

#### 2.2. ULID

- **장점**
  - 타임스탬프 기반 상위 바이트 → 시간 순 정렬 가능
  - 128비트지만 GUID보다 인덱스 효율성 우수
- **단점**
  - 구현 복잡도↑
  - 충돌 확률은 랜덤 파트 크기에 의존

#### 2.3. Snowflake (예: Twitter Snowflake)

- **구조**
  - 64비트: [타임스탬프(41bit)] + [머신 ID(10bit)] + [시퀀스(12bit)]
- **장점**
  - 1밀리초당 4096개 생성 가능 → 초당 수백만 건 처리
  - 시간 순 보장, 정렬 인덱스 효율적
  - 완전 분산: 단일 토큰 서버 미존재
- **단점**
  - 머신 ID 충돌·중복 방지 체계 필요(ZooKeeper, Redis 등)
  - 시스템 시계 뒤로 감김(clock rollback) 방지 로직 필요

| 전략                     | 설명                                                                      | 장점                                                  | 단점                                                    | 추천 사용 상황                               |
|------------------------|-------------------------------------------------------------------------|-----------------------------------------------------|-------------------------------------------------------|----------------------------------------|
| **Sequence + Hi/Lo**   | 데이터베이스 SEQUENCE를 블록(예: 1000개) 단위로 미리 가져와 애플리케이션에서 Hi/Lo 방식으로 세부 ID를 채번. | - DB 왕복 횟수 대폭 절감 → 처리량↑- 순차 증가 보장 → 인덱스 단편화 최소화     | - 블록 미소진 시 ID 공백 발생- 블록 크기 튜닝 필요                      | DB 종속은 유지하되, 쓰기 성능만 개선하고 싶을 때          |
| **UUID (v4)**          | 128비트 랜덤 기반 GUID. 애플리케이션 단에서 완전 분산으로 생성.                                | - 중앙 시스템 불필요- 충돌 확률 극히 낮음- 표준화된 포맷                  | - 128비트 랜덤 → 인덱스 단편화 심화- 스토리지·네트워크 오버헤드 (16바이트)       |                                        |
| - 순서가 보장되지 않음          | 간단히 분산 유니크 ID만 필요할 때                                                    |                                                     |                                                       |                                        |
| **ULID**               | 128비트: 상위 48비트 타임스탬프 + 하위 80비트 랜덤. Base32 문자열(26자)로 표현.                 | - 시간 순 정렬(lexico) 보장- 노드 ID 불필요- 문자열 포맷으로 외부 노출에 용이 | - 문자열 길이(26자) → 저장·인덱스 오버헤드- 충돌 이론적 가능성(랜덤 부분)        | 로그·URL 등에 사람이 읽을 수 있는 시간순 ID가 필요할 때    |
| **Snowflake**          | 64비트: 41비트 타임스탬프 + 10비트 노드ID + 12비트 시퀀스. 노드별 고유 ID 관리 필요.               | - 1ms당 수천 건 생성 가능- 숫자형 → 인덱스·저장 공간 효율적- 시간 순 정렬 보장  | - 노드ID 충돌 방지 체계 필요(ZooKeeper/Redis 등)- 시계 역행 대응 로직 필요 | 고성능 분산 환경에서 숫자형, 시간순 ID를 원할 때          |
| **Redis INCR 기반**      | Redis의 `INCR` 명령으로 중앙 카운터 관리. 애플리케이션에서 `INCR` 결과를 ID로 사용.               | - 구현·운영 간단- 빠른 처리 속도- 분산 접근 가능                      | - Redis 장애 시 ID 발급 중단(SPOF)- 단일 시퀀스 병목 우려             | Redis 가 이미 캐시/세션 등으로 운영 중인 환경에서 가볍게 사용 |
| **KSUID (K-Sortable)** | 160비트: 32비트 타임스탬프 + 128비트 랜덤. Base62 인코딩(27자) 사용.                       | - 시간 순 정렬 보장- 아주 낮은 충돌 확률- 문자열로 외부 노출 용이            | - 20바이트 크기 → 스토리지·네트워크 오버헤드- 구현 라이브러리 제약              | 글로벌 분산 환경에서 시간순 문자열 ID·충돌 저항성이 필요할 때   |

## ID 채번 전략을 선택할 때 고려사항

- **일관성 있는 정렬이 중요**하다면 → **Snowflake/ULID**
  - 정렬 인덱스 단편화 최소화
  - Java/Kotlin 라이브러리(`sonyflake`, `leaf` 등) 활용
- **DB 의존 최소화 + 블로킹 방지**가 목표라면 → **Snowflake 계열**
  - 인프라가 허용한다면 → 클러스터별 머신 ID 관리
- **간단히 도입하면서도 성능 확보**를 원한다면 → **Sequence + Hi/Lo**
  - Hibernate 사용 시 `@GenericGenerator(name="hilo", strategy="enhanced-sequence", parameters={…})` 설정
  - 블록 크기(`allocationSize`) 조정으로 트래픽 패턴에 최적화
- **UUID/ULID vs. Snowflake**
  - UUID는 편리하지만 색인 효율이 낮으므로, **시간 기반 ULID** 혹은 **Snowflake**를 권장

## 결론

- **최대 처리량·낮은 레이턴시·분산 안정성**을 모두 고려한다면, **Twitter Snowflake**(또는 ULID) 같은 애플리케이션 수준의 분산 ID 생성기를 도입하는 것이 가장 무난
- **단계적 도입**을 원한다면, 먼저 **DB Sequence + Hi/Lo** 전략으로 시작한 뒤, 차후 Snowflake로 전환하는 것도 좋은 로드맵
